<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XOR Cipher by @ciphermalware</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        h1 {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        h1 span {
            font-size: 18px;
            font-weight: normal;
        }
        h2 {
            font-weight: bold;
            margin-bottom: 10px;
        }
        h3 {
            font-weight: 600;
            margin-bottom: 5px;
        }
        textarea, input {
            margin: 8px 0;
            padding: 8px;
            width: 100%;
            box-sizing: border-box;
            font-family: monospace;
        }
        .result {
            background-color: white;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 3px;
            min-height: 20px;
            word-break: break-all;
            margin-bottom: 10px;
            font-family: monospace;
        }
        button {
            background-color: #4285f4;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 0;
        }
        button:hover {
            background-color: #3b78e7;
        }
        select {
            padding: 8px;
            margin: 8px 0;
        }
        .chart-container {
            height: 200px;
            margin: 15px 0;
            background-color: white;
            padding: 10px;
            border: 1px solid #ddd;
        }
        .bar {
            display: inline-block;
            background-color: #4285f4;
            margin-right: 2px;
            position: relative;
        }
        .bar-label {
            position: absolute;
            bottom: -20px;
            width: 100%;
            text-align: center;
            font-size: 12px;
        }
        .loading {
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: #666;
        }
        .key-candidate {
            margin-bottom: 5px;
            padding: 5px;
            background-color: #e9f5ff;
            border-radius: 3px;
            cursor: pointer;
        }
        .key-candidate:hover {
            background-color: #d0e8ff;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            padding: 5px;
            border-radius: 3px;
        }
        .key-length-option {
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 10px;
            padding: 5px 10px;
            background-color: #e9e9e9;
            border-radius: 3px;
            cursor: pointer;
        }
        .key-length-option:hover, .key-length-option.selected {
            background-color: #4285f4;
            color: white;
        }
        .decrypted-preview {
            font-family: monospace;
        }
        #analysis-section {
            display: none;
        }
        #frequency-charts {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .freq-chart {
            flex: 1 1 45%;
            min-width: 300px;
            margin-bottom: 20px;
        }
        .freq-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .decryption-result {
            padding: 10px;
            margin: 10px 0;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .edge-cases {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .edge-case {
            width: 100%;
        }
        .format-option {
            display: inline-block;
            margin-right: 10px;
        }
        .entropy-bar {
            margin-top: 5px;
            height: 20px;
            background-color: #e9e9e9;
            position: relative;
        }
        .entropy-value {
            position: absolute;
            height: 100%;
            background-color: #4285f4;
        }
        .entropy-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            line-height: 20px;
        }
        #key-visualization {
            overflow-x: auto;
            white-space: nowrap;
            margin: 10px 0;
            font-family: monospace;
        }
        .byte-cell {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 1px solid #ddd;
            text-align: center;
            line-height: 24px;
            margin-right: 2px;
            background-color: #f8f9fa;
        }
        @media (max-width: 600px) {
            .edge-cases {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>XOR Cipher <span>by @ciphermalware</span></h1>
    
    <div class="container">
        <h2>Encryption/Decryption</h2>
        <div>
            <label for="input-format">Input Format:</label>
            <div>
                <label class="format-option"><input type="radio" name="input-format" value="text" checked> Text</label>
                <label class="format-option"><input type="radio" name="input-format" value="hex"> Hex</label>
                <label class="format-option"><input type="radio" name="input-format" value="base64"> Base64</label>
            </div>
        </div>

        <div>
            <label for="plaintext">Input:</label>
            <textarea id="plaintext" rows="3">Hello, this is an XOR cipher example</textarea>
        </div>
        
        <div>
            <label for="key">XOR Key (text, hex, or base64):</label>
            <input type="text" id="key" value="SECRET">
            <div>
                <label class="format-option"><input type="radio" name="key-format" value="text" checked> Text</label>
                <label class="format-option"><input type="radio" name="key-format" value="hex"> Hex</label>
                <label class="format-option"><input type="radio" name="key-format" value="base64"> Base64</label>
            </div>
        </div>
        
        <div>
            <label for="output-format">Output Format:</label>
            <div>
                <label class="format-option"><input type="radio" name="output-format" value="hex" checked> Hex</label>
                <label class="format-option"><input type="radio" name="output-format" value="base64"> Base64</label>
                <label class="format-option"><input type="radio" name="output-format" value="text"> Text (may display unusable characters)</label>
            </div>
        </div>
        
        <div>
            <button id="encrypt-btn">XOR Encrypt/Decrypt</button>
        </div>
        
        <div>
            <label for="result">Result:</label>
            <div id="result" class="result"></div>
            <div>
                <button id="copy-result" style="background-color: #5f6368;">Copy Result</button>
                <button id="use-as-input" style="background-color: #5f6368;">Use as Input</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h2>Cipher Analysis and Breaking</h2>
        <div>
            <label for="ciphertext">Encrypted Data to Analyze:</label>
            <textarea id="ciphertext" rows="4"></textarea>
            <div>
                <label class="format-option"><input type="radio" name="cipher-format" value="hex" checked> Hex</label>
                <label class="format-option"><input type="radio" name="cipher-format" value="base64"> Base64</label>
                <label class="format-option"><input type="radio" name="cipher-format" value="text"> Text</label>
            </div>
        </div>
        
        <div>
            <h3>Analysis Options</h3>
            <div>
                <label for="max-key-length">Maximum Key Length to Check:</label>
                <input type="number" id="max-key-length" value="12" min="1" max="30">
            </div>
            <div>
                <label for="analysis-method">Analysis Method:</label>
                <select id="analysis-method">
                    <option value="hamming">Hamming Distance (better for text)</option>
                    <option value="ioc">Index of Coincidence</option>
                    <option value="entropy">Entropy Analysis</option>
                </select>
            </div>
        </div>
        
        <button id="analyze-cipher-btn">Analyze Encrypted Data</button>
        
        <div id="breaking-status" class="loading" style="display: none;">Analyzing encrypted data...</div>
        
        <div id="analysis-section">
            <h3>Key Length Analysis</h3>
            <p>Potential key lengths (the lower the score, the more likely):</p>
            <div id="key-lengths"></div>
            
            <div id="key-length-details">
                <h3>Frequency Analysis</h3>
                <p>Select a key length to see byte frequency analysis and possible key:</p>
                <div id="frequency-charts"></div>
                
                <h3>Key Visualization</h3>
                <div id="key-visualization"></div>
                
                <h3>Key Candidates</h3>
                <div id="key-candidates"></div>
                
                <h3>Decryption Preview</h3>
                <div id="decryption-results"></div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h2>Test Examples</h2>
        <div class="edge-cases">
            <button class="edge-case" data-text="This is a secret message" data-key="KEY" data-format="text">Simple Text (KEY)</button>
            <button class="edge-case" data-text="The quick brown fox jumps over the lazy dog" data-key="SECRET" data-format="text">English Pangram (SECRET)</button>
            <button class="edge-case" data-text="48656c6c6f20576f726c642c20585252206973206675"  data-key="4d79" data-format="hex">Hello World in Hex (My)</button>
            <button class="edge-case" data-text="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" data-key="FF" data-format="hex">Repeated Data (FF)</button>
        </div>
    </div>

    <script>
        
        function base64ToBytes(base64) {
            try {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes;
            } catch (e) {
                console.error("Invalid base64:", e);
                return new Uint8Array(0);
            }
        }
        
        function bytesToBase64(bytes) {
            let binary = '';
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }
        
        
        function hexToBytes(hex) {
            hex = hex.replace(/\s/g, '');
            if (hex.length % 2 !== 0) {
              
                hex = '0' + hex;
            }
            
            const byteArray = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                const byteValue = parseInt(hex.substr(i, 2), 16);
                if (isNaN(byteValue)) {
                    console.error(`Invalid hex at position ${i}: ${hex.substr(i, 2)}`);
                    return new Uint8Array(0);
                }
                byteArray[i/2] = byteValue;
            }
            return byteArray;
        }
        
        function bytesToHex(bytes) {
            return Array.from(bytes)
                .map(byte => byte.toString(16).padStart(2, '0'))
                .join('');
        }
        
        function textToBytes(text) {
            const encoder = new TextEncoder();
            return encoder.encode(text);
        }
        
        function bytesToText(bytes) {
            const decoder = new TextDecoder();
            return decoder.decode(bytes);
        }
        
        
        function getInputBytes() {
            const inputText = document.getElementById('plaintext').value;
            const inputFormat = document.querySelector('input[name="input-format"]:checked').value;
            
            if (inputFormat === 'text') {
                return textToBytes(inputText);
            } else if (inputFormat === 'hex') {
                return hexToBytes(inputText);
            } else if (inputFormat === 'base64') {
                return base64ToBytes(inputText);
            }
            return new Uint8Array(0);
        }
        
        function getKeyBytes() {
            const keyText = document.getElementById('key').value;
            const keyFormat = document.querySelector('input[name="key-format"]:checked').value;
            
            if (keyFormat === 'text') {
                return textToBytes(keyText);
            } else if (keyFormat === 'hex') {
                return hexToBytes(keyText);
            } else if (keyFormat === 'base64') {
                return base64ToBytes(keyText);
            }
            return new Uint8Array(0);
        }
        
        function formatOutputBytes(bytes) {
            const outputFormat = document.querySelector('input[name="output-format"]:checked').value;
            
            if (outputFormat === 'text') {
                return bytesToText(bytes);
            } else if (outputFormat === 'hex') {
                return bytesToHex(bytes);
            } else if (outputFormat === 'base64') {
                return bytesToBase64(bytes);
            }
            return '';
        }
        
        
        function xorCipher(data, key) {
            if (key.length === 0) return data;
            
            const result = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
                result[i] = data[i] ^ key[i % key.length];
            }
            
            return result;
        }
        
      
        function hammingDistance(bytes1, bytes2) {
            let distance = 0;
            const minLength = Math.min(bytes1.length, bytes2.length);
            
            for (let i = 0; i < minLength; i++) {
             
                let xor = bytes1[i] ^ bytes2[i];
                while (xor) {
                    distance += xor & 1;
                    xor >>= 1;
                }
            }
            
         
            distance += Math.abs(bytes1.length - bytes2.length) * 8;
            
            return distance;
        }
        
        
        function calculateHammingDistances(bytes, keyLength) {
            const numBlocks = Math.floor(bytes.length / keyLength);
            if (numBlocks < 2) return 1;
            
            let totalDistance = 0;
            let comparisons = 0;
            
            
            for (let i = 0; i < numBlocks - 1; i++) {
                const block1 = bytes.slice(i * keyLength, (i + 1) * keyLength);
                
                for (let j = i + 1; j < numBlocks; j++) {
                    const block2 = bytes.slice(j * keyLength, (j + 1) * keyLength);
                    totalDistance += hammingDistance(block1, block2);
                    comparisons++;
                }
            }
            
           
            return totalDistance / (keyLength * 8 * comparisons);
        }
        
       
        function calculateIC(bytes) {
            const freqs = new Array(256).fill(0);
            
           
            for (let i = 0; i < bytes.length; i++) {
                freqs[bytes[i]]++;
            }
            
            let sum = 0;
            const n = bytes.length;
            
            for (let i = 0; i < 256; i++) {
                const count = freqs[i];
                if (count > 1) {
                    sum += count * (count - 1);
                }
            }
            
            
            return sum / (n * (n - 1));
        }
        
        
        function calculateAverageIC(bytes, keyLength) {
            if (bytes.length < keyLength * 2) return 0;
            
            let totalIC = 0;
            
            for (let i = 0; i < keyLength; i++) {
                const byteStream = [];
                
                for (let j = i; j < bytes.length; j += keyLength) {
                    byteStream.push(bytes[j]);
                }
                
                totalIC += calculateIC(new Uint8Array(byteStream));
            }
            
            return totalIC / keyLength;
        }
        
        
        function calculateEntropy(bytes) {
            const freqs = new Array(256).fill(0);
            
          
            for (let i = 0; i < bytes.length; i++) {
                freqs[bytes[i]]++;
            }
            
            let entropy = 0;
            
            for (let i = 0; i < 256; i++) {
                const p = freqs[i] / bytes.length;
                if (p > 0) {
                    entropy -= p * Math.log2(p);
                }
            }
            
            return entropy;
        }
        
       
        function calculateStreamEntropy(bytes, keyLength) {
            let totalEntropy = 0;
            
            for (let i = 0; i < keyLength; i++) {
                const byteStream = [];
                
                for (let j = i; j < bytes.length; j += keyLength) {
                    byteStream.push(bytes[j]);
                }
                
                totalEntropy += calculateEntropy(new Uint8Array(byteStream));
            }
            
            return totalEntropy / keyLength;
        }
        
        
        function findKeyLengths(bytes, maxLength = 12, method = 'hamming') {
            const results = [];
            
            
            maxLength = Math.min(maxLength, Math.floor(bytes.length / 2));
            
            for (let keyLength = 1; keyLength <= maxLength; keyLength++) {
                let score;
                
                if (method === 'hamming') {
                    score = calculateHammingDistances(bytes, keyLength);
                } else if (method === 'ioc') {
                    score = -calculateAverageIC(bytes, keyLength); 
                } else if (method === 'entropy') {
                    score = calculateStreamEntropy(bytes, keyLength);
                }
                
                results.push({ keyLength, score });
            }
            
            
            results.sort((a, b) => a.score - b.score);
            
            return results;
        }
        
        
        function getByteFrequencies(bytes, keyLength) {
            const positions = [];
            
            for (let i = 0; i < keyLength; i++) {
                const freqs = new Array(256).fill(0);
                let count = 0;
                
                for (let j = i; j < bytes.length; j += keyLength) {
                    freqs[bytes[j]]++;
                    count++;
                }
                
                
                for (let k = 0; k < 256; k++) {
                    freqs[k] /= count;
                }
                
                positions.push(freqs);
            }
            
            return positions;
        }
        
       
        const englishFreqValues = {
            32: 0.18,  
            101: 0.10, 
            116: 0.07, 
            97: 0.065,  
            111: 0.06, 
            110: 0.057, 
            105: 0.057, 
            115: 0.057, 
            114: 0.05,  
            108: 0.035, 
            100: 0.033, 
            104: 0.03,  
            99: 0.025   
        };
        
        
        function guessKeyByte(byteFrequencies) {
            const scores = [];
            
            for (let key = 0; key < 256; key++) {
                let score = 0;
                
                
                for (let byte = 0; byte < 256; byte++) {
                    const decryptedByte = byte ^ key;
                    const expectedFreq = englishFreqValues[decryptedByte] || 0.0025; 
                    const observedFreq = byteFrequencies[byte] || 0;
                    
                   
                    const diff = observedFreq - expectedFreq;
                    score += (diff * diff) / (expectedFreq || 0.0001);
                }
                
                scores.push({ key, score });
            }
            
           
            scores.sort((a, b) => a.score - b.score);
            
            return scores[0].key;
        }
        
        
        function guessKey(bytes, keyLength) {
            const byteFrequencies = getByteFrequencies(bytes, keyLength);
            const key = new Uint8Array(keyLength);
            
            for (let i = 0; i < keyLength; i++) {
                key[i] = guessKeyByte(byteFrequencies[i]);
            }
            
            return key;
        }
        
      
        document.addEventListener('DOMContentLoaded', function() {
            const plaintextEl = document.getElementById('plaintext');
            const keyEl = document.getElementById('key');
            const resultEl = document.getElementById('result');
            const encryptBtn = document.getElementById('encrypt-btn');
            const copyResultBtn = document.getElementById('copy-result');
            const useAsInputBtn = document.getElementById('use-as-input');
            const ciphertextEl = document.getElementById('ciphertext');
            const analyzeCipherBtn = document.getElementById('analyze-cipher-btn');
            const breakingStatusEl = document.getElementById('breaking-status');
            const analysisSection = document.getElementById('analysis-section');
            const keyLengthsEl = document.getElementById('key-lengths');
            const frequencyChartsEl = document.getElementById('frequency-charts');
            const keyVisualizationEl = document.getElementById('key-visualization');
            const keyCandidatesEl = document.getElementById('key-candidates');
            const decryptionResultsEl = document.getElementById('decryption-results');
            const maxKeyLengthEl = document.getElementById('max-key-length');
            const analysisMethodEl = document.getElementById('analysis-method');
            const edgeCases = document.querySelectorAll('.edge-case');
            
          
            encryptBtn.addEventListener('click', function() {
                const dataBytes = getInputBytes();
                const keyBytes = getKeyBytes();
                
                if (keyBytes.length === 0) {
                    resultEl.textContent = 'Error: Invalid key format';
                    return;
                }
                
                const resultBytes = xorCipher(dataBytes, keyBytes);
                resultEl.textContent = formatOutputBytes(resultBytes);
            });
            
            
            copyResultBtn.addEventListener('click', function() {
                const text = resultEl.textContent;
                navigator.clipboard.writeText(text)
                    .then(() => {
                        const originalText = copyResultBtn.textContent;
                        copyResultBtn.textContent = 'Copied!';
                        setTimeout(() => {
                            copyResultBtn.textContent = originalText;
                        }, 1500);
                    })
                    .catch(err => {
                        console.error('Error copying text: ', err);
                    });
            });
            
            
            useAsInputBtn.addEventListener('click', function() {
                const text = resultEl.textContent;
                const outputFormat = document.querySelector('input[name="output-format"]:checked').value;
                
                
                ciphertextEl.value = text;
                
               
                document.querySelectorAll('input[name="cipher-format"]').forEach(radio => {
                    if (radio.value === outputFormat) {
                        radio.checked = true;
                    }
                });
            });
            
            
            analyzeCipherBtn.addEventListener('click', function() {
                const ciphertext = ciphertextEl.value;
                if (!ciphertext.trim()) return;
                
                const cipherFormat = document.querySelector('input[name="cipher-format"]:checked').value;
                let cipherBytes;
                
                if (cipherFormat === 'text') {
                    cipherBytes = textToBytes(ciphertext);
                } else if (cipherFormat === 'hex') {
                    cipherBytes = hexToBytes(ciphertext);
                } else if (cipherFormat === 'base64') {
                    cipherBytes = base64ToBytes(ciphertext);
                }
                
                if (cipherBytes.length === 0) {
                    alert('Error: Invalid cipher format');
                    return;
                }
                
                breakingStatusEl.style.display = 'block';
                analysisSection.style.display = 'none';
                
                keyLengthsEl.innerHTML = '';
                frequencyChartsEl.innerHTML = '';
                keyVisualizationEl.innerHTML = '';
                keyCandidatesEl.innerHTML = '';
                decryptionResultsEl.innerHTML = '';
                
                setTimeout(function() {
                    const maxKeyLength = parseInt(maxKeyLengthEl.value) || 12;
                    const method = analysisMethodEl.value;
                    
                    const keyLengthResults = findKeyLengths(cipherBytes, maxKeyLength, method);
                    
                   
                    keyLengthResults.slice(0, 10).forEach(result => {
                        const el = document.createElement('div');
                        el.className = 'key-length-option';
                        el.textContent = `Length ${result.keyLength} (Score: ${result.score.toFixed(4)})`;
                        el.dataset.length = result.keyLength;
                        keyLengthsEl.appendChild(el);
                    });
                    
                   
                    const keyLengthOptions = document.querySelectorAll('.key-length-option');
                    keyLengthOptions.forEach(option => {
                        option.addEventListener('click', function() {
                            keyLengthOptions.forEach(opt => opt.classList.remove('selected'));
                            this.classList.add('selected');
                            
                            const keyLength = parseInt(this.dataset.length);
                            
                            frequencyChartsEl.innerHTML = '';
                            keyVisualizationEl.innerHTML = '';
                            keyCandidatesEl.innerHTML = '';
                            decryptionResultsEl.innerHTML = '';
                            
                            
                            const byteFreqs = getByteFrequencies(cipherBytes, keyLength);
                            
                   
                            byteFreqs.forEach((freqs, index) => {
                                const chartDiv = document.createElement('div');
                                chartDiv.className = 'freq-chart';
                                
                                const title = document.createElement('div');
                                title.className = 'freq-title';
                                title.textContent = `Key Byte ${index+1} Analysis`;
                                chartDiv.appendChild(title);
                                
                                
                                const positionData = [];
                                for (let j = index; j < cipherBytes.length; j += keyLength) {
                                    positionData.push(cipherBytes[j]);
                                }
                                const entropy = calculateEntropy(new Uint8Array(positionData));
                                
                                const entropyDiv = document.createElement('div');
                                entropyDiv.textContent = `Entropy: ${entropy.toFixed(2)} bits`;
                                chartDiv.appendChild(entropyDiv);
                                
                                const entropyBar = document.createElement('div');
                                entropyBar.className = 'entropy-bar';
                                const entropyValue = document.createElement('div');
                                entropyValue.className = 'entropy-value';
                                entropyValue.style.width = `${(entropy / 8) * 100}%`;
                                const entropyText = document.createElement('div');
                                entropyText.className = 'entropy-text';
                                entropyText.textContent = `${entropy.toFixed(2)}/8`;
                                
                                entropyBar.appendChild(entropyValue);
                                entropyBar.appendChild(entropyText);
                                chartDiv.appendChild(entropyBar);
                                
                                
                                if (index < 4) {
                                    const chartContainer = document.createElement('div');
                                    chartContainer.className = 'chart-container';
                                    chartContainer.style.height = '100px';
                                    
                                   
                                    const topBytes = [];
                                    for (let i = 0; i < 256; i++) {
                                        if (freqs[i] > 0) {
                                            topBytes.push({ byte: i, freq: freqs[i] });
                                        }
                                    }
                                    topBytes.sort((a, b) => b.freq - a.freq);
                                    
                                  
                                    const displayCount = Math.min(topBytes.length, 20);
                                    for (let i = 0; i < displayCount; i++) {
                                        const byteData = topBytes[i];
                                        const bar = document.createElement('div');
                                        bar.className = 'bar';
                                        bar.style.height = `${byteData.freq * 100}px`;
                                        bar.style.width = '10px';
                                        
                                        const label = document.createElement('div');
                                        label.className = 'bar-label';
                                        label.textContent = byteData.byte.toString(16).padStart(2, '0');
                                        
                                        bar.appendChild(label);
                                        chartContainer.appendChild(bar);
                                    }
                                    
                                    chartDiv.appendChild(chartContainer);
                                }
                                
                                frequencyChartsEl.appendChild(chartDiv);
                            });
                            
                            
                            const guessedKey = guessKey(cipherBytes, keyLength);
                            
                            
                            keyVisualizationEl.innerHTML = '';
                            for (let i = 0; i < guessedKey.length; i++) {
                                const cell = document.createElement('div');
                                cell.className = 'byte-cell';
                                cell.textContent = guessedKey[i].toString(16).padStart(2, '0');
                                keyVisualizationEl.appendChild(cell);
                            }
                            
                            
                            const keyHex = bytesToHex(guessedKey);
                            const keyText = bytesToText(guessedKey);
                            const keyBase64 = bytesToBase64(guessedKey);
                            
                            const keyHexEl = document.createElement('div');
                            keyHexEl.className = 'key-candidate';
                            keyHexEl.textContent = `Hex key: ${keyHex}`;
                            keyHexEl.dataset.key = keyHex;
                            keyHexEl.dataset.format = 'hex';
                            keyCandidatesEl.appendChild(keyHexEl);
                            
                            const keyTextEl = document.createElement('div');
                            keyTextEl.className = 'key-candidate';
                            keyTextEl.textContent = `Text key: ${keyText.replace(/[^\x20-\x7E]/g, '·')}`;
                            keyTextEl.dataset.key = keyText;
                            keyTextEl.dataset.format = 'text';
                            keyCandidatesEl.appendChild(keyTextEl);
                            
                            const keyBase64El = document.createElement('div');
                            keyBase64El.className = 'key-candidate';
                            keyBase64El.textContent = `Base64 key: ${keyBase64}`;
                            keyBase64El.dataset.key = keyBase64;
                            keyBase64El.dataset.format = 'base64';
                            keyCandidatesEl.appendChild(keyBase64El);
                            
                      
                            document.querySelectorAll('.key-candidate').forEach(candidate => {
                                candidate.addEventListener('click', function() {
                                    document.getElementById('key').value = this.dataset.key;
                                    
                                  
                                    document.querySelectorAll('input[name="key-format"]').forEach(radio => {
                                        if (radio.value === this.dataset.format) {
                                            radio.checked = true;
                                        }
                                    });
                                });
                            });
                            
                          
                            const decrypted = xorCipher(cipherBytes, guessedKey);
                            
                           
                            try {
                                const decryptedText = bytesToText(decrypted).replace(/[^\x20-\x7E]/g, '·');
                                
                                
                                let printableCount = 0;
                                for (let i = 0; i < decryptedText.length; i++) {
                                    if (decryptedText[i] !== '·') {
                                        printableCount++;
                                    }
                                }
                                const printablePercentage = (printableCount / decryptedText.length * 100).toFixed(1);
                                
                                const decryptedEl = document.createElement('div');
                                decryptedEl.className = 'decryption-result';
                                
                                const decryptedHeader = document.createElement('h4');
                                decryptedHeader.textContent = `Decrypted (${printablePercentage}% printable characters):`;
                                decryptedEl.appendChild(decryptedHeader);
                                
                                const decryptedContent = document.createElement('div');
                                decryptedContent.className = 'decrypted-preview';
                                decryptedContent.textContent = decryptedText;
                                decryptedEl.appendChild(decryptedContent);
                                
                               
                                const decryptedHex = document.createElement('div');
                                decryptedHex.style.marginTop = '10px';
                                decryptedHex.style.fontSize = '12px';
                                decryptedHex.textContent = `Hex: ${bytesToHex(decrypted).slice(0, 100)}${decrypted.length > 50 ? '...' : ''}`;
                                decryptedEl.appendChild(decryptedHex);
                                
                                decryptionResultsEl.appendChild(decryptedEl);
                                
                                
                                const useKeyBtn = document.createElement('button');
                                useKeyBtn.textContent = 'Use This Key for Decryption';
                                useKeyBtn.style.marginTop = '10px';
                                useKeyBtn.addEventListener('click', function() {
                                    document.getElementById('key').value = keyHex;
                                    
                                 
                                    document.querySelectorAll('input[name="key-format"]').forEach(radio => {
                                        if (radio.value === 'hex') {
                                            radio.checked = true;
                                        }
                                    });
                                    
                                 
                                    document.getElementById('plaintext').value = ciphertextEl.value;
                                    
                              
                                    document.querySelectorAll('input[name="input-format"]').forEach(radio => {
                                        if (radio.value === document.querySelector('input[name="cipher-format"]:checked').value) {
                                            radio.checked = true;
                                        }
                                    });
                                    
                                    
                                    document.querySelector('.container').scrollIntoView({ behavior: 'smooth' });
                                });
                                decryptionResultsEl.appendChild(useKeyBtn);
                            } catch (e) {
                                console.error('Text decoding error:', e);
                                
                                const errorEl = document.createElement('div');
                                errorEl.className = 'decryption-result';
                                errorEl.textContent = 'Error decoding text. Try another key length.';
                                decryptionResultsEl.appendChild(errorEl);
                            }
                        });
                    });
                    
                    breakingStatusEl.style.display = 'none';
                    analysisSection.style.display = 'block';
                    
                    
                    if (keyLengthOptions.length > 0) {
                        keyLengthOptions[0].click();
                    }
                }, 100);
            });
            
            
            edgeCases.forEach(button => {
                button.addEventListener('click', function() {
                    const text = this.dataset.text;
                    const key = this.dataset.key;
                    const format = this.dataset.format || 'text';
                    
                    
                    plaintextEl.value = text;
                    
                  
                    document.querySelectorAll('input[name="input-format"]').forEach(radio => {
                        if (radio.value === format) {
                            radio.checked = true;
                        }
                    });
                    
                    
                    keyEl.value = key;
                    
                    
                    document.querySelectorAll('input[name="key-format"]').forEach(radio => {
                        if (radio.value === format) {
                            radio.checked = true;
                        }
                    });
                    
                    
                    encryptBtn.click();
                });
            });
        });
    </script>
</body>
</html>
